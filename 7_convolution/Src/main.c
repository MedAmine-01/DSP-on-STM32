/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"
#include "signals.h"
#include "uart.h"
#include <stdio.h>
#include "systick.h"



#define GPIOAEN			(1U<<0)
#define PIN5			(1U<<5)
#define LED_PIN			PIN5


extern float _5hz_signal[HZ_5_SIG_LEN];
extern float32_t inputSignal_f32_1kHz_15kHz[KHZ1_15_SIG_LEN];
extern float32_t  impulse_response[IMP_RESP_LEN];
float32_t convoluted_signal[KHZ1_15_SIG_LEN+IMP_RESP_LEN-1];
float32_t convoluted_signal_cmsis_dsp[KHZ1_15_SIG_LEN+IMP_RESP_LEN-1];
float32_t running_sum_signal[KHZ1_15_SIG_LEN];

uint32_t before, after, timeElapsed;
float seconds;

float sig_sample;
float convoluted_sample;
float convoluted_sample_cmsis_dsp;
float running_sum_sample;




static void plot_input_signal(void);
static void pseudo_delay(void);

static void convolution1(float32_t * input_signal, float32_t *impulse_signal, uint32_t input_length, uint32_t impulse_length, float32_t * output_signal);
static void convolution2(float32_t * input_signal, float32_t* impulse_signal, uint32_t input_length, uint32_t impulse_length, float32_t * output_signal);
static void running_sum(float32_t * input_signal, uint32_t signal_lenght, float32_t * output_signal);


int main(void)
{
	//Enable Floating Point Unit
	SCB->CPACR |= ((3UL<<20)| (3UL<<22));	//full access to cp11 and cp10 (refer to cortex user guide (fpu))

	uart2_tx_init();
	systick_init();
	before=SysTick->VAL;
	convolution1(inputSignal_f32_1kHz_15kHz, impulse_response, (uint32_t) KHZ1_15_SIG_LEN, (uint32_t) IMP_RESP_LEN, convoluted_signal);
	after=SysTick->VAL;
	arm_conv_f32(inputSignal_f32_1kHz_15kHz, (uint32_t) KHZ1_15_SIG_LEN, impulse_response, (uint32_t) IMP_RESP_LEN, convoluted_signal_cmsis_dsp);
	timeElapsed = before-after;
	seconds=(float)timeElapsed/16000000;

	//a running sum can be used as a lowpass filter
	running_sum(inputSignal_f32_1kHz_15kHz, (uint32_t) KHZ1_15_SIG_LEN, running_sum_signal);

	plot_input_signal();
	while(1){
		//printf("Hello from STM32\n\r");
	}
}
static void plot_input_signal(void){
	for(int i=0;i< IMP_RESP_LEN+KHZ1_15_SIG_LEN-1 ;i++){
		convoluted_sample=convoluted_signal[i];
		convoluted_sample_cmsis_dsp=convoluted_signal_cmsis_dsp[i];
		if(i<KHZ1_15_SIG_LEN){
			running_sum_sample= running_sum_signal[i];
			sig_sample=inputSignal_f32_1kHz_15kHz[i];
		}
		//printf("%f\n\r",convoluted_signal[i]);
		pseudo_delay();
	}
}

static void pseudo_delay(void){
	 for(int i=0;i <100000; i++){

	 }
}

static void convolution1(float32_t * input_signal, float32_t* impulse_signal, uint32_t input_length, uint32_t impulse_length, float32_t * output_signal){
	for(int i=0;i<input_length+impulse_length-1;i++){
		for(int j=0;j<impulse_length;j++){
			if((i - j) >= 0 && (i - j) < input_length){
				output_signal[i] += impulse_signal[j] * input_signal[i - j];
			}
		}
	}
}

static void convolution2(float32_t * input_signal, float32_t* impulse_signal, uint32_t input_length, uint32_t impulse_length, float32_t * output_signal){
	for(int i=0;i<input_length+impulse_length-1;i++){
		output_signal[i]=0;
	}
	for(int i=0;i<input_length;i++){
		for(int j=0;j<impulse_length;j++){
			output_signal[i+j] += impulse_signal[j] * input_signal[i];
		}
	}
}

static void running_sum(float32_t * input_signal, uint32_t signal_lenght, float32_t * output_signal){
	for(int i=0;i<signal_lenght;i++){
		output_signal[i]=output_signal[i-1] + input_signal[i];
	}
}
