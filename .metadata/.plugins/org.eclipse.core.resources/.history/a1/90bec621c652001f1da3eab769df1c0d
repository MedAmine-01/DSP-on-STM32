/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"
#include "signals.h"
#include "uart.h"
#include <stdio.h>
#include "adc.h"
#include "fir_filter.h"
#include "fifo.h"
#include "tim.h"


#define ORIGINAL_SIG_LEN		RX_FIFO_SIZE


extern float32_t filter[LPF_LEN];

uint32_t filtered_signal[ORIGINAL_SIG_LEN+LPF_LEN-1];

rx_dataType data_chunck[RX_FIFO_SIZE];

uint32_t timer;
uint8_t fifo_full_flag=1, process_flag;
uint16_t sensor_value;

void clear_data_buffer(void);
static uint8_t read_fifo(rx_dataType *destination);
static void convolution(uint32_t * input_signal, float32_t* impulse_signal, uint32_t input_length, uint32_t impulse_length, uint32_t * output_signal);
static void plot_input_signal(void);
static void pseudo_delay(void);



int main(void)
{
	//Enable Floating Point Unit
 	SCB->CPACR |= ((3UL<<20)| (3UL<<22));	//full access to cp11 and cp10 (refer to cortex user guide (fpu))


 	RCC->AHB1ENR |= (1<<0);
 	GPIOA->MODER |= (1<<10);
 	GPIOA->MODER &=~ (1<<11);



 	tim2_1hz_interrupt_init();
 	uart2_tx_init();
 	pa1_adc_init();
 	start_conversion();
 	rx_fifo_init();

	while(1){
		if(process_flag){
			clear_data_buffer();

			for(int i=0;i<RX_FIFO_SIZE;i++){
				/*wait until entire batch is collected from adc*/
				while(fifo_full_flag==1);
				fifo_full_flag=read_fifo(data_chunck+i);
			}

			//Perfor DSP

			convolution(data_chunck, filter, ORIGINAL_SIG_LEN, LPF_LEN, filtered_signal);
			int j=0;
			for(int i=0;i<RX_FIFO_SIZE+LPF_LEN;i++){
				j++;
				if(j==RX_FIFO_SIZE){
					j=0;
				}
				printf("%d,",filtered_signal[i]);
				printf("%d\n\r",(int) data_chunck[j]);
			}

			//reset process flag
			process_flag = 0;
		}
	}
}
static void plot_input_signal(void){
	for(int i=0;i< KHZ1_15_SIG_LEN ;i++){
		pseudo_delay();
	}
}



static void pseudo_delay(void){
	 for(int i=0;i <100000; i++){

	 }
}

static void tim2_callback(void){
	//check if fifo not full
	if(fifo_full_flag==1){
		fifo_full_flag=rx_fifo_put(adc_read());
	}
	else{
		process_flag=1;
	}
}

void TIM2_IRQHandler(){
	/*Clear update Interrupt flag*/
	TIM2->SR&=~(1<<0);
	/*Do ISR*/
	tim2_callback();
}

void clear_data_buffer(void){
	for(int i=0;i<RX_FIFO_SIZE;i++){
		data_chunck[i]=0;
	}
}

static uint8_t read_fifo(rx_dataType *destination){
	__IO uint8_t read_flag;
	read_flag = rx_fifo_get(destination);

	//this will start the fifo_put routine again to collect the next batcch of samples
	if(read_flag==0){
		fifo_full_flag = RX_FIFO_SUCCESS;
	}
	else {
		fifo_full_flag = RX_FIFO_FAIL;
	}
	return fifo_full_flag;
}

static void convolution(uint32_t * input_signal, float32_t* impulse_signal, uint32_t input_length, uint32_t impulse_length, uint32_t * output_signal){
	for(int i=0;i<input_length+impulse_length-1;i++){
		output_signal[i]=0;
	}
	for(int i=0;i<input_length;i++){
		for(int j=0;j<impulse_length;j++){
			output_signal[i+j] += impulse_signal[j] * input_signal[i];
		}
	}
}



